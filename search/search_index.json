{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u26a1 Dispytch","text":"<p>Dispytch is a lightweight, async-first Python framework for event-handling. It\u2019s designed to streamline the development of clean and testable event-driven services.</p>"},{"location":"#features","title":"\ud83d\ude80 Features","text":"<ul> <li>\ud83e\udde0 Async-first core \u2013 built for modern Python I/O</li> <li>\ud83d\udd0c FastAPI-style dependency injection \u2013 clean, decoupled handlers</li> <li>\ud83d\udcec Backend-flexible \u2013 with Kafka and RabbitMQ out-of-the-box</li> <li>\ud83e\uddf1 Composable architecture \u2013 extend, override, or inject anything</li> <li>\ud83e\uddfe Pydantic-based validation \u2013 event schemas are validated using pydantic </li> <li>\ud83d\udd01 Built-in retry logic \u2013 configurable, resilient, no boilerplate</li> </ul>"},{"location":"#example-handling-events","title":"\u2728 Example: Handling Events","text":"<pre><code>from typing import Annotated\nfrom pydantic import BaseModel\nfrom dispytch import Event, Dependency, HandlerGroup\nfrom service import UserService, get_user_service\n\nclass User(BaseModel):\n    id: str\n    email: str\n    name: str\n\nclass UserCreatedEvent(BaseModel):\n    user: User\n    timestamp: int\n\nuser_events = HandlerGroup()\n\n@user_events.handler(topic='user_events', event='user_registered')\nasync def handle_user_registered(\n    event: Event[UserCreatedEvent],\n    user_service: Annotated[UserService, Dependency(get_user_service)]\n):\n    user = event.body.user\n    timestamp = event.body.timestamp\n    print(f\"[User Registered] {user.id} - {user.email} at {timestamp}\")\n    await user_service.do_smth_with_the_user(user)\n</code></pre>"},{"location":"#example-emitting-events","title":"\u2728 Example: Emitting Events","text":"<pre><code>import uuid\nfrom datetime import datetime\nfrom pydantic import BaseModel\nfrom dispytch import EventBase\n\nclass User(BaseModel):\n    id: str\n    email: str\n    name: str\n\nclass UserRegistered(EventBase):\n    __topic__ = \"user_events\"\n    __event_type__ = \"user_registered\"\n\n    user: User\n    timestamp: int\n\nasync def example_emit(emitter):\n    await emitter.emit(\n        UserRegistered(\n            user=User(\n                id=str(uuid.uuid4()),\n                email=\"example@mail.com\",\n                name=\"John Doe\",\n            ),\n            timestamp=int(datetime.now().timestamp()),\n        )\n    )\n</code></pre>"},{"location":"#limitations","title":"\u26a0\ufe0f Limitations","text":""},{"location":"#no-schema-on-write-support","title":"\ud83e\uddfe No schema-on-write support","text":"<p>Dispytch uses a schema-on-read model. Formats like Avro, Protobuf, or Thrift aren\u2019t supported yet.</p>"},{"location":"#no-dead-letter-queue-dlq","title":"\ud83d\udd75\ufe0f No dead-letter queue (DLQ)","text":"<p>Failed messages are retried using built-in logic, but there\u2019s no DLQ or fallback mechanism after final retries yet.</p>"},{"location":"#no-topic-pattern-matching","title":"\ud83e\udde9 No topic pattern matching","text":"<p>Wildcard or templated subscriptions (e.g. <code>user.*</code>, <code>order:{id}:events</code>) aren\u2019t supported in handler declarations yet.</p> <p>\ud83d\udca1 See something missing? Some features aren\u2019t here yet\u2014but with your help, they could be. Contributions welcome via PRs or discussions.</p>"},{"location":"backends/kafka/","title":"Kafka Backend","text":"<p>Dispytch has first-class support for Kafka as a message broker.</p> <p>It supports: - Emitting events to Kafka topics via a producer - Consuming events from Kafka topics via a listener - Manual partitioning via <code>__partition_by__</code></p>"},{"location":"backends/kafka/#installation","title":"Installation","text":"<pre><code>pip install dispytch[kafka]\n````\n\nThis installs the required dependencies like `aiokafka`.\n\n---\n\n## Producing Events (KafkaProducer)\n\nUse the built-in Kafka producer to emit events:\n\n```python\nfrom aiokafka import AIOKafkaProducer\nfrom dispytch_kafka import KafkaProducer\nfrom dispytch import EventEmitter\n\naioproducer = AIOKafkaProducer(bootstrap_servers=\"localhost:9092\")\nawait aioproducer.start()\n\nproducer = KafkaProducer(aioproducer)\nemitter = EventEmitter(producer)\n</code></pre> <p>Then emit as usual:</p> <pre><code>await emitter.emit(UserRegistered(...))\n</code></pre>"},{"location":"backends/kafka/#consuming-events-kafkaconsumer","title":"Consuming Events (KafkaConsumer)","text":"<p>Create a Kafka consumer and wire it into Dispytch:</p> <pre><code>from aiokafka import AIOKafkaConsumer\nfrom dispytch_kafka import KafkaConsumer\nfrom dispytch import EventListener\n\naioconsumer = AIOKafkaConsumer(\n    \"user_events\",\n    bootstrap_servers=\"localhost:9092\",\n    group_id=\"my-service\"\n)\nawait aioconsumer.start()\n\nconsumer = KafkaConsumer(aioconsumer)\nlistener = EventListener(consumer)\n</code></pre>"},{"location":"backends/kafka/#partitioning-events","title":"Partitioning Events","text":"<p>Kafka supports partitioned topics for scaling and ordering guarantees. Dispytch allows you to specify a partition key:</p> <pre><code>class UserRegistered(EventBase):\n    __topic__ = \"user_events\"\n    __event_type__ = \"user_registered\"\n    __partition_by__ = \"user.id\"  # supports dotted paths\n\n    user: dict\n    timestamp: int\n</code></pre> <p>Dispytch extracts the key at runtime and routes messages accordingly.</p>"},{"location":"backends/kafka/#notes","title":"Notes","text":"<ul> <li>Dispytch does not manage topic creation or schema registration.</li> <li>Kafka retries and acks are handled at the Dispytch level, not via Kafka-specific settings.</li> <li>All messages are JSON-serialized using Pydantic under the hood.</li> </ul>"},{"location":"backends/rabbitmq/","title":"RabbitMQ Backend","text":"<p>Dispytch supports RabbitMQ as a backend for both emitting and consuming events.</p> <p>It integrates cleanly with <code>aio-pika</code>, using AMQP 0.9.1 under the hood.</p>"},{"location":"backends/rabbitmq/#installation","title":"Installation","text":"<pre><code>pip install dispytch[rabbitmq]\n````\n\nThis installs `aio-pika` and necessary dependencies.\n\n---\n\n## Producing Events (RabbitMQ Producer)\n\nTo emit events via RabbitMQ:\n\n```python\nimport aio_pika\nfrom dispytch_rabbitmq import RabbitMQProducer\nfrom dispytch import EventEmitter\n\nconnection = await aio_pika.connect_robust(\"amqp://guest:guest@localhost/\")\nchannel = await connection.channel()\n\nproducer = RabbitMQProducer(channel)\nemitter = EventEmitter(producer)\n</code></pre> <p>Now you can emit events like this:</p> <pre><code>await emitter.emit(UserRegistered(...))\n</code></pre>"},{"location":"backends/rabbitmq/#consuming-events-rabbitmq-consumer","title":"Consuming Events (RabbitMQ Consumer)","text":"<p>To listen for events:</p> <pre><code>from dispytch_rabbitmq import RabbitMQConsumer\nfrom dispytch import EventListener\n\nconsumer = RabbitMQConsumer(channel, queue_name=\"user_events\")\nlistener = EventListener(consumer)\n</code></pre> <p>Add your handlers and start listening:</p> <pre><code>listener.add_handler_group(user_events)\nawait listener.listen()\n</code></pre>"},{"location":"backends/rabbitmq/#notes-on-rabbitmq-integration","title":"Notes on RabbitMQ Integration","text":"<ul> <li>Each topic maps to a RabbitMQ queue.</li> <li>Messages are encoded as JSON.</li> <li>Acknowledgements are managed manually after successful handler execution.</li> <li>RabbitMQ does not support native partitions, so <code>__partition_by__</code> is ignored.</li> <li>Retry logic is handled by Dispytch \u2014 not RabbitMQ DLX or redelivery.</li> </ul>"},{"location":"backends/rabbitmq/#example-queue-declaration-optional","title":"Example Queue Declaration (Optional)","text":"<p>You can declare queues manually if needed:</p> <pre><code>await channel.declare_queue(\"user_events\", durable=True)\n</code></pre> <p>Dispytch will not auto-create queues.</p>"},{"location":"concepts/architecture/","title":"Architecture Overview","text":"<p>Dispytch is designed as a modular, async-first event-handling framework for Python, built to simplify event-driven microservices.</p>"},{"location":"concepts/architecture/#core-components","title":"Core Components","text":"<ul> <li> <p>EventBase   The base class for all events. Events are typed Pydantic models with metadata (<code>__topic__</code>, <code>__event_type__</code>, etc.) that define where and how they get published.</p> </li> <li> <p>EventEmitter   Sends events to a backend (e.g., Kafka, RabbitMQ). Wraps a low-level producer and handles serialization, metadata, and partitioning.</p> </li> <li> <p>EventListener   Consumes events from the backend and dispatches them to registered handlers asynchronously. Manages task concurrency and retries.</p> </li> <li> <p>HandlerGroup   A registry to group and organize handlers by topic and event type, supporting decorators to simplify registration.</p> </li> <li> <p>Dependency Injection (DI)   Inspired by FastAPI, Dispytch allows you to annotate handler parameters for automatic dependency resolution, improving testability and modularity.</p> </li> </ul>"},{"location":"concepts/architecture/#workflow","title":"Workflow","text":"<ol> <li> <p>Define events by subclassing <code>EventBase</code>, specifying topic, event type, and payload.</p> </li> <li> <p>Register handlers for events using decorators in <code>HandlerGroup</code> or directly on <code>EventListener</code>.</p> </li> <li> <p>Use <code>EventEmitter</code> to send events to the backend.</p> </li> <li> <p>The <code>EventListener</code> consumes incoming events and routes them to matching handlers, injecting dependencies.</p> </li> <li> <p>Built-in retry logic manages transient failures without boilerplate.</p> </li> </ol>"},{"location":"concepts/architecture/#extensibility","title":"Extensibility","text":"<p>Dispytch is backend-agnostic and built to be composable. You can extend or override producers, consumers, and other core pieces without rewriting your business logic.</p>"},{"location":"concepts/architecture/#key-design-goals","title":"Key Design Goals","text":"<ul> <li>Async-first for scalability  </li> <li>Minimal boilerplate  </li> <li>Testability with pure async coroutines  </li> <li>Backend flexibility (Kafka, RabbitMQ, or custom)  </li> <li>Clear separation of concerns</li> </ul>"},{"location":"concepts/di/","title":"Dependency Injection (DI)","text":"<p>Dispytch incorporates a FastAPI-inspired Dependency Injection system to simplify handler dependencies and improve testability.</p>"},{"location":"concepts/di/#why-di","title":"Why DI?","text":"<ul> <li>Decouples handler business logic from infrastructure concerns.</li> <li>Enables clean, declarative handler signatures.</li> <li>Automatically resolves and injects dependencies at runtime.</li> <li>Supports async and sync dependencies.</li> </ul>"},{"location":"concepts/di/#how-it-works","title":"How It Works","text":"<p>Handlers declare dependencies using Python\u2019s type annotations combined with Dispytch\u2019s <code>Dependency</code> wrapper.</p> <p>Example:</p> <pre><code>from typing import Annotated\nfrom dispytch import Dependency\n\nasync def get_user_service():\n    # Setup or retrieve a service instance\n    return UserService()\n\n@handler_group.handler(topic=\"user_events\", event=\"user_registered\")\nasync def handle_user_registered(\n    event: Event[UserRegisteredEvent],\n    user_service: Annotated[UserService, Dependency(get_user_service)]\n):\n    await user_service.do_something(event.body.user)\n</code></pre> <p>At runtime, Dispytch:</p> <ol> <li>Inspects the handler\u2019s parameters.</li> <li>Detects <code>Dependency</code> annotations.</li> <li>Resolves and injects the requested dependencies before invoking the handler.</li> </ol>"},{"location":"concepts/di/#features","title":"Features","text":"<ul> <li>Supports async/sync factory functions for dependencies.</li> <li>Automatically manages dependency lifecycles.</li> <li>Allows passing context, such as the current event, to dependency resolvers.</li> <li>Easily testable by overriding dependencies in tests.</li> </ul>"},{"location":"concepts/di/#advanced-usage","title":"Advanced Usage","text":"<p>You can create reusable dependencies for common resources (DB sessions, caches, config objects), keeping your handlers clean and focused.</p>"},{"location":"concepts/di/#notes","title":"Notes","text":"<ul> <li>DI is optional but recommended for complex services.</li> <li>Keep dependency trees shallow to avoid performance issues.</li> <li>Currently designed to work seamlessly within Dispytch\u2019s event handling lifecycle.</li> </ul>"},{"location":"concepts/emitter/","title":"EventEmitter","text":"<p>The EventEmitter is responsible for sending events to your chosen backend system, such as Kafka or RabbitMQ.</p>"},{"location":"concepts/emitter/#overview","title":"Overview","text":"<ul> <li>Wraps a low-level <code>Producer</code> interface.</li> <li>Accepts <code>EventBase</code> instances and serializes them into messages with metadata.</li> <li>Handles partition key extraction for partitioned backends like Kafka.</li> <li>Sends the message asynchronously.</li> </ul>"},{"location":"concepts/emitter/#usage","title":"Usage","text":"<p>```python from dispytch.emitter.event import EventBase from dispytch.emitter.producer import Producer from dispytch.emitter import EventEmitter</p> <p>class UserRegistered(EventBase):     topic = \"user_events\"     event_type = \"user_registered\"     partition_by = \"user.id\"</p> <pre><code>user: dict\ntimestamp: int\n</code></pre> <p>producer = Producer(...)  # your Kafka or RabbitMQ producer setup emitter = EventEmitter(producer)</p> <p>await emitter.emit(UserRegistered(user={\"id\": \"123\"}, timestamp=1234567890))</p>"},{"location":"concepts/handler-groups/","title":"HandlerGroup","text":"<p>A HandlerGroup is a container that organizes and registers event handlers by topic and event type.</p>"},{"location":"concepts/handler-groups/#purpose","title":"Purpose","text":"<ul> <li>Helps you group related handlers logically.</li> <li>Simplifies handler registration with decorators.</li> <li>Supports default topic and event values to reduce repetition.</li> <li>Stores metadata like retry settings per handler.</li> </ul>"},{"location":"concepts/handler-groups/#usage","title":"Usage","text":"<p>Create a handler group and register handlers using the <code>.handler()</code> decorator:</p> <pre><code>from dispytch import HandlerGroup\n\nuser_events = HandlerGroup(default_topic=\"user_events\")\n\n@user_events.handler(event=\"user_registered\", retries=3, retry_interval=2.0)\nasync def handle_user_registered(event):\n    print(f\"User registered: {event.body}\")\n</code></pre>"},{"location":"concepts/handler-groups/#handler-registration","title":"Handler Registration","text":"<p>The <code>.handler()</code> decorator accepts:</p> Parameter Description Default <code>topic</code> Event topic to listen to (overrides default_topic) <code>default_topic</code> if set, else required <code>event</code> Event type to handle (overrides default_event) <code>default_event</code> if set, else required <code>retries</code> Number of retry attempts on failure <code>0</code> <code>retry_on</code> Exception type to trigger retries (any if not set) <code>Exception</code> <code>retry_interval</code> Delay between retries in seconds <code>1.25</code>"},{"location":"concepts/handler-groups/#registering-with-an-eventlistener","title":"Registering with an EventListener","text":"<p>To use a <code>HandlerGroup</code>, register it with an <code>EventListener</code>:</p> <pre><code>listener.add_handler_group(user_events)\n</code></pre> <p>This imports all handlers in the group into the listener\u2019s dispatching system.</p>"},{"location":"concepts/handler-groups/#error-handling-validation","title":"Error Handling &amp; Validation","text":"<ul> <li>Raises <code>TypeError</code> if topic or event type is not specified either in the decorator or default group.</li> <li>Supports flexible retry strategies for robust event processing.</li> </ul>"},{"location":"concepts/listener/","title":"EventListener","text":"<p>The EventListener orchestrates consuming events from your backend and dispatching them to the right handlers.</p>"},{"location":"concepts/listener/#overview","title":"Overview","text":"<ul> <li>Consumes events asynchronously from a <code>Consumer</code> interface.</li> <li>Matches events by topic and event type to registered handlers.</li> <li>Supports concurrent handler execution with asyncio tasks.</li> <li>Provides retry logic and error logging on failures.</li> <li>Supports handler registration via decorators or by importing <code>HandlerGroup</code>s.</li> </ul>"},{"location":"concepts/listener/#core-responsibilities","title":"Core Responsibilities","text":"<ol> <li> <p>Listening    Uses <code>async for</code> to listen for incoming events from the backend.</p> </li> <li> <p>Dispatching    Finds all handlers matching the event\u2019s topic and type.</p> </li> <li> <p>Dependency Injection    Injects dependencies into handlers, allowing clean, decoupled code.</p> </li> <li> <p>Task Management    Creates asyncio tasks for each handler call and manages their lifecycle.</p> </li> <li> <p>Acknowledgement    Calls the consumer\u2019s ack method on successful handling.</p> </li> </ol>"},{"location":"concepts/listener/#example-usage","title":"Example Usage","text":"<pre><code>listener = EventListener(consumer)  # consumer is your Kafka/RabbitMQ consumer instance\n\n@listener.handler(topic=\"user_events\", event=\"user_registered\")\nasync def handle_user_registered(event):\n    print(f\"Received user_registered: {event.body}\")\n\nawait listener.listen()\n</code></pre>"},{"location":"concepts/listener/#registering-handler-groups","title":"Registering Handler Groups","text":"<p>You can register multiple handlers grouped logically:</p> <pre><code>listener.add_handler_group(user_events)\n</code></pre> <p>Where <code>user_events</code> is an instance of <code>HandlerGroup</code> containing handlers registered via decorators.</p>"},{"location":"concepts/listener/#notes","title":"Notes","text":"<ul> <li>If no handler matches an event, an info log is emitted.</li> <li>Handler failures log exceptions but do not crash the listener.</li> <li>Retries and retry intervals can be configured per handler.</li> </ul>"},{"location":"getting-started/installation/","title":"\ud83d\udce6 Installation","text":"<p>Dispytch is backend-agnostic by default. This means it won't install Kafka or RabbitMQ dependencies unless explicitly requested.</p> <p>Install with <code>uv</code> or <code>pip</code>, including extras for your preferred message broker:</p>"},{"location":"getting-started/installation/#with-kafka-support","title":"With Kafka support","text":"<pre><code>uv add dispytch[kafka]\n# or\npip install dispytch[kafka]\n</code></pre> <p>Includes: <code>aiokafka</code></p>"},{"location":"getting-started/installation/#with-rabbitmq-support","title":"With RabbitMQ support","text":"<pre><code>uv add dispytch[rabbitmq]\n# or\npip install dispytch[rabbitmq]\n</code></pre> <p>Includes: <code>aio-pika</code></p>"},{"location":"getting-started/installation/#no-backend-by-default","title":"\u26a0\ufe0f No Backend by Default","text":"<p>If you install Dispytch without any extras:</p> <pre><code>uv add dispytch\n# or\npip install dispytch\n</code></pre> <p>then no producer or consumer backends will be available. You'll need to install at least one extra (<code>[kafka]</code> or <code>[rabbitmq]</code>) or install the dependencies separately to use built-in event producers and consumers.</p>"},{"location":"getting-started/installation/#custom-backends","title":"\ud83d\udd27 Custom Backends","text":"<p>If you're building your own backend implementation (e.g., for Redis, NATS, SQS, etc.), installing Dispytch without extras is exactly what you want.</p>"},{"location":"getting-started/quickstart/","title":"\ud83d\ude80 Quickstart","text":"<p>Get your event-driven flow running with Dispytch in four simple steps.</p>"},{"location":"getting-started/quickstart/#1-define-your-event","title":"1. Define Your Event","text":"<p>Subclass <code>EventBase</code> to declare your event\u2019s topic and type metadata, along with its payload:</p> <pre><code>from dispytch import EventBase\n\n\nclass UserRegistered(EventBase):\n    __topic__ = \"user_events\"\n    __event_type__ = \"user_registered\"\n\n    user_id: str\n    email: str\n</code></pre>"},{"location":"getting-started/quickstart/#2-emit-events","title":"2. Emit Events","text":"<p>Create an <code>EventEmitter</code> with your configured backend producer, then emit events asynchronously:</p> <pre><code>from dispytch.emitter import EventEmitter\nfrom events import UserRegistered\n\nproducer = ...  # your backend producer setup\nemitter = EventEmitter(producer)\n\n\nasync def emit_user_registered():\n    await emitter.emit(UserRegistered(user_id=\"123\", email=\"user@example.com\"))\n</code></pre>"},{"location":"getting-started/quickstart/#3-register-event-handlers","title":"3. Register Event Handlers","text":"<p>Organize handlers with <code>HandlerGroup</code>. Define the event schema (usually a Pydantic model), then decorate your async handler:</p> <pre><code>from pydantic import BaseModel\nfrom dispytch import HandlerGroup, Event\n\n\nclass UserRegisteredBody(BaseModel):\n    user_id: str\n    email: str\n\n\nuser_events = HandlerGroup(default_topic=\"user_events\")\n\n\n@user_events.handler(event=\"user_registered\")\nasync def handle_user_registered(event: Event[UserRegisteredBody]):\n    print(f\"User {event.body.user_id} registered with email {event.body.email}\")\n</code></pre>"},{"location":"getting-started/quickstart/#4-start-the-listener","title":"4. Start the Listener","text":"<p>Connect your backend consumer to an <code>EventListener</code>, register your handler group(s), then listen for incoming events:</p> <pre><code>import asyncio\nfrom dispytch.listener import EventListener\nfrom handlers import user_events\n\nconsumer = ...  # your backend consumer setup\nlistener = EventListener(consumer)\nlistener.add_handler_group(user_events)\n\nif __name__ == \"__main__\":\n    asyncio.run(listener.listen())\n</code></pre>"},{"location":"getting-started/quickstart/#thats-it","title":"That\u2019s It!","text":"<p>Define events, emit them, handle them asynchronously \u2014 all wired up and ready to roll.</p>"}]}